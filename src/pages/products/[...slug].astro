---
import Layout from '@/layouts/Layout.astro';
import { Providers } from '@/components/common/Providers';
import HeaderWrapper from '@/components/Header/HeaderWrapper';
import FooterV2 from '@/components/FooterV2';
import ProductDetail from '@/components/products/ProductDetail';
import { getProducts, getRelatedProducts } from '@/utils/products';
import { getBlobImageUrl } from '@/utils/blobStorage';
import productsData from '@/data/productsSimplified.json';

// Generate static paths for all products
export async function getStaticPaths() {
  // Helper to normalize product names for URL matching
  function normalizeForUrl(str: string): string {
    return str.toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '');
  }

  const paths: any[] = [];
  
  if (!productsData || !productsData.products) {
    console.error('Products data or products array missing');
    return [];
  }

  // Handle both /product/:id and /products/:category/:id patterns
  for (const product of productsData.products) {
    if (product.id) {
      // Try to get fresh product data from API
      let productData = product;
      try {
        const freshProduct = await getProducts().then(products => 
          products.find(p => p.id.toLowerCase() === product.id.toLowerCase())
        );
        if (freshProduct) {
          productData = freshProduct;
        }
      } catch (error) {
        console.warn(`Could not fetch fresh data for ${product.id}, using static data`);
      }

      // Product by ID only (e.g., /products/tac-734g)
      paths.push({
        params: { slug: product.id },
        props: { product: productData },
      });
      
      // Product with category/id (e.g., /products/bond/oa23)
      if (product.category) {
        const categorySlug = product.category.toLowerCase();
        paths.push({
          params: { slug: `${categorySlug}/${product.id}` },
          props: { product: productData, productCategory: categorySlug },
        });
      }
      
      // Also create redirect paths for product name variations
      if (product.name) {
        const normalizedName = normalizeForUrl(product.name);
        // Only add if different from the ID
        if (normalizedName !== product.id.toLowerCase()) {
          paths.push({
            params: { slug: normalizedName },
            props: { 
              product: productData, 
              redirectTo: `/products/${product.category.toLowerCase()}/${product.id.toLowerCase()}`,
              isRedirect: true
            },
          });
        }
      }
    }
  }
  
  return paths;
}

const { slug } = Astro.params;
const { product, productCategory, redirectTo, isRedirect } = Astro.props;
const currentPath = Astro.url.pathname;

// Handle redirect case - return early with redirect response
if (isRedirect && redirectTo) {
  return Astro.redirect(redirectTo, 301);
}

// Format the product name for display
const productName = product?.name || product?.id || 'Product';
const productDescription = product?.description || `${productName} - High-performance industrial product from ForzaBuilt.`;

// Get related products
let relatedProducts: any[] = [];
try {
  if (product?.id) {
    // Get all products and filter for ones with images
    const allProducts = await getProducts();
    
    // Filter for products with actual images (exclude current product)
    const productsWithImages = allProducts.filter(p => 
      p.id !== product.id && 
      p.imageUrl && 
      p.imageUrl.trim() !== '' &&
      !p.imageUrl.includes('placeholder') &&
      !p.imageUrl.includes('logo')
    );
    
    // Try to get products from different categories first, then fall back to same industry
    let related: any[] = [];
    
    // Get products from different categories
    const differentCategory = productsWithImages.filter(p => 
      p.category?.toLowerCase() !== product.category?.toLowerCase()
    );
    
    // Get products from same industry but different category
    const sameIndustryDifferentCategory = productsWithImages.filter(p => 
      p.category?.toLowerCase() !== product.category?.toLowerCase() &&
      p.industry && 
      Array.isArray(p.industry) &&
      product.industry &&
      Array.isArray(product.industry) &&
      p.industry.some(ind => product.industry.includes(ind))
    );
    
    // Combine: prefer different category, then same industry different category, then any with images
    if (differentCategory.length > 0) {
      related = differentCategory.slice(0, 4);
    } else if (sameIndustryDifferentCategory.length > 0) {
      related = sameIndustryDifferentCategory.slice(0, 4);
    } else {
      // Fall back to same industry with images
      const sameIndustry = productsWithImages.filter(p => 
        p.industry && 
        Array.isArray(p.industry) &&
        product.industry &&
        Array.isArray(product.industry) &&
        p.industry.some(ind => product.industry.includes(ind))
      );
      related = sameIndustry.slice(0, 4);
    }
    
    // If still not enough, fill with any products with images
    if (related.length < 4) {
      const remaining = productsWithImages
        .filter(p => !related.some(r => r.id === p.id))
        .slice(0, 4 - related.length);
      related = [...related, ...remaining];
    }
    
    relatedProducts = related;
  }
} catch (error) {
  console.error('Failed to fetch related products:', error);
  relatedProducts = [];
}

// Build product structured data for SEO
const productStructuredData = product ? {
  "@context": "https://schema.org",
  "@type": "Product",
  "name": productName,
  "description": productDescription,
  "brand": {
    "@type": "Brand",
    "name": "ForzaBuilt"
  },
  "manufacturer": {
    "@type": "Organization",
    "name": "ForzaBuilt"
  },
  "category": product.category || "Industrial Products",
  ...(product.imageUrl && { "image": product.imageUrl }),
  "url": `https://forzabuilt.com${currentPath}`
} : null;
---

<Layout 
  title={`${productName} - ForzaBuilt`}
  description={productDescription}
  canonicalUrl={currentPath}
  ogType="product"
  structuredData={productStructuredData}
>
  <Providers client:load>
    <div class="bg-white min-h-screen flex flex-col relative overflow-x-hidden">
      <HeaderWrapper currentPath={currentPath} />
      
      <ProductDetail 
        product={product} 
        relatedProducts={relatedProducts}
        productCategory={productCategory}
        client:load 
      />
      
      <FooterV2 />
    </div>
  </Providers>
</Layout>
