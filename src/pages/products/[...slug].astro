---
import Layout from '@/layouts/Layout.astro';
import { Providers } from '@/components/common/Providers';
import HeaderWrapper from '@/components/Header/HeaderWrapper';
import FooterV2 from '@/components/FooterV2';
import ProductDetail from '@/components/products/ProductDetail';
import { getProducts, getRelatedProducts } from '@/utils/products';
import { getBlobImageUrl } from '@/utils/blobStorage';
import productsData from '@/data/productsSimplified.json';

// Generate static paths for all products
export async function getStaticPaths() {
  // Helper to normalize product names for URL matching
  function normalizeForUrl(str: string): string {
    return str.toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '');
  }

  const paths: any[] = [];
  
  if (!productsData || !productsData.products) {
    console.error('Products data or products array missing');
    return [];
  }

  // Fetch all products once to use as a lookup
  let allApiProducts: any[] = [];
  try {
    allApiProducts = await getProducts();
  } catch (error) {
    console.warn('Could not fetch products from API, falling back to static data');
  }

  // Handle both /product/:id and /products/:category/:id patterns
  for (const product of productsData.products) {
    if (product.id) {
      // Try to get fresh product data from the pre-fetched list
      let productData = product;
      const freshProduct = allApiProducts.find(p => p.id.toLowerCase() === product.id.toLowerCase());
      
      if (freshProduct) {
        productData = freshProduct;
      }

      // Product by ID only (e.g., /products/tac-734g)
      paths.push({
        params: { slug: product.id },
        props: { 
          product: productData,
          relatedProducts: [] // Default for ID-only paths to keep it light
        },
      });
      
      // Product with category/id (e.g., /products/bond/oa23)
      if (product.category) {
        const categorySlug = product.category.toLowerCase();
        
        // Find related products for this specific product during build
        let related: any[] = [];
        try {
          const productsWithImages = allApiProducts.filter(p => 
            p.id !== product.id && 
            p.imageUrl && 
            p.imageUrl.trim() !== '' &&
            !p.imageUrl.includes('placeholder') &&
            !p.imageUrl.includes('logo')
          );
          
          const differentCategory = productsWithImages.filter(p => 
            p.category?.toLowerCase() !== product.category?.toLowerCase()
          );
          
          if (differentCategory.length > 0) {
            related = differentCategory.slice(0, 4);
          } else {
            const sameIndustry = productsWithImages.filter(p => 
              p.industry && 
              Array.isArray(p.industry) &&
              product.industry &&
              Array.isArray(product.industry) &&
              p.industry.some(ind => product.industry.includes(ind))
            );
            related = sameIndustry.slice(0, 4);
          }
          
          if (related.length < 4) {
            const remaining = productsWithImages
              .filter(p => !related.some(r => r.id === p.id))
              .slice(0, 4 - related.length);
            related = [...related, ...remaining];
          }
        } catch (e) {
          console.error('Error finding related products in getStaticPaths:', e);
        }

        paths.push({
          params: { slug: `${categorySlug}/${product.id}` },
          props: { 
            product: productData, 
            productCategory: categorySlug,
            relatedProducts: related 
          },
        });
      }
      
      // Also create redirect paths for product name variations
      if (product.name) {
        const normalizedName = normalizeForUrl(product.name);
        // Only add if different from the ID
        if (normalizedName !== product.id.toLowerCase()) {
          paths.push({
            params: { slug: normalizedName },
            props: { 
              product: productData, 
              redirectTo: `/products/${product.category.toLowerCase()}/${product.id.toLowerCase()}`,
              isRedirect: true
            },
          });
        }
      }
    }
  }
  
  return paths;
}

const { slug } = Astro.params;
const { product, productCategory, redirectTo, isRedirect } = Astro.props;
const currentPath = Astro.url.pathname;

// Handle redirect case - return early with redirect response
if (isRedirect && redirectTo) {
  return Astro.redirect(redirectTo, 301);
}

// Format the product name for display
const productName = product?.name || product?.id || 'Product';
const productDescription = product?.description || `${productName} - High-performance industrial product from ForzaBuilt.`;

// Get related products from props
const relatedProducts = Astro.props.relatedProducts || [];

// Build product structured data for SEO
const productStructuredData = product ? {
  "@context": "https://schema.org",
  "@type": "Product",
  "name": productName,
  "description": productDescription,
  "brand": {
    "@type": "Brand",
    "name": "ForzaBuilt"
  },
  "manufacturer": {
    "@type": "Organization",
    "name": "ForzaBuilt"
  },
  "category": product.category || "Industrial Products",
  ...(product.imageUrl && { "image": product.imageUrl }),
  "url": `https://forzabuilt.com${currentPath}`
} : null;
---

<Layout 
  title={`${productName} - ForzaBuilt`}
  description={productDescription}
  canonicalUrl={currentPath}
  ogType="product"
  structuredData={productStructuredData}
>
  <Providers client:load>
    <div class="bg-white min-h-screen flex flex-col relative overflow-x-hidden">
      <HeaderWrapper currentPath={currentPath} />
      
      <ProductDetail 
        product={product} 
        relatedProducts={relatedProducts}
        productCategory={productCategory}
        client:load 
      />
      
      <FooterV2 />
    </div>
  </Providers>
</Layout>
